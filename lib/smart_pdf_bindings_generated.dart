// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Dart bindings for PDFium.
/// Current included headers:
/// - fpdfview.h
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class SmartPdfBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  SmartPdfBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  SmartPdfBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Function: FPDF_InitLibrary
  /// Initialize the FPDFSDK library
  /// Parameters:
  /// None
  /// Return value:
  /// None.
  /// Comments:
  /// Convenience function to call FPDF_InitLibraryWithConfig() for
  /// backwards compatibility purposes. This will be deprecated in the
  /// future.
  void FPDF_InitLibrary() {
    return _FPDF_InitLibrary();
  }

  late final _FPDF_InitLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('FPDF_InitLibrary');
  late final _FPDF_InitLibrary =
      _FPDF_InitLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_InitLibraryWithConfig
  /// Initialize the FPDFSDK library
  /// Parameters:
  /// config - configuration information as above.
  /// Return value:
  /// None.
  /// Comments:
  /// You have to call this function before you can call any PDF
  /// processing functions.
  void FPDF_InitLibraryWithConfig(
    ffi.Pointer<FPDF_LIBRARY_CONFIG> config,
  ) {
    return _FPDF_InitLibraryWithConfig(
      config,
    );
  }

  late final _FPDF_InitLibraryWithConfigPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FPDF_LIBRARY_CONFIG>)>>('FPDF_InitLibraryWithConfig');
  late final _FPDF_InitLibraryWithConfig = _FPDF_InitLibraryWithConfigPtr
      .asFunction<void Function(ffi.Pointer<FPDF_LIBRARY_CONFIG>)>();

  /// Function: FPDF_DestroyLibary
  /// Release all resources allocated by the FPDFSDK library.
  /// Parameters:
  /// None.
  /// Return value:
  /// None.
  /// Comments:
  /// You can call this function to release all memory blocks allocated by
  /// the library.
  /// After this function is called, you should not call any PDF
  /// processing functions.
  void FPDF_DestroyLibrary() {
    return _FPDF_DestroyLibrary();
  }

  late final _FPDF_DestroyLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('FPDF_DestroyLibrary');
  late final _FPDF_DestroyLibrary =
      _FPDF_DestroyLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_SetSandBoxPolicy
  /// Set the policy for the sandbox environment.
  /// Parameters:
  /// policy -   The specified policy for setting, for example:
  /// FPDF_POLICY_MACHINETIME_ACCESS.
  /// enable -   True to enable, false to disable the policy.
  /// Return value:
  /// None.
  void FPDF_SetSandBoxPolicy(
    int policy,
    int enable,
  ) {
    return _FPDF_SetSandBoxPolicy(
      policy,
      enable,
    );
  }

  late final _FPDF_SetSandBoxPolicyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DWORD, FPDF_BOOL)>>(
          'FPDF_SetSandBoxPolicy');
  late final _FPDF_SetSandBoxPolicy =
      _FPDF_SetSandBoxPolicyPtr.asFunction<void Function(int, int)>();

  /// Experimental API.
  /// Function: FPDF_SetPrintMode
  /// Set printing mode when printing on Windows.
  /// Parameters:
  /// mode - FPDF_PRINTMODE_EMF to output EMF (default)
  /// FPDF_PRINTMODE_TEXTONLY to output text only (for charstream
  /// devices)
  /// FPDF_PRINTMODE_POSTSCRIPT2 to output level 2 PostScript into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT3 to output level 3 PostScript into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH to output level 2
  /// PostScript via ExtEscape() in PASSTHROUGH mode.
  /// FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH to output level 3
  /// PostScript via ExtEscape() in PASSTHROUGH mode.
  /// FPDF_PRINTMODE_EMF_IMAGE_MASKS to output EMF, with more
  /// efficient processing of documents containing image masks.
  /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42 to output level 3
  /// PostScript with embedded Type 42 fonts, when applicable, into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH to output level
  /// 3 PostScript with embedded Type 42 fonts, when applicable,
  /// via ExtEscape() in PASSTHROUGH mode.
  /// Return value:
  /// True if successful, false if unsuccessful (typically invalid input).
  int FPDF_SetPrintMode(
    int mode,
  ) {
    return _FPDF_SetPrintMode(
      mode,
    );
  }

  late final _FPDF_SetPrintModePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(ffi.Int)>>(
          'FPDF_SetPrintMode');
  late final _FPDF_SetPrintMode =
      _FPDF_SetPrintModePtr.asFunction<int Function(int)>();

  /// Function: FPDF_LoadDocument
  /// Open and load a PDF document.
  /// Parameters:
  /// file_path -  Path to the PDF file (including extension).
  /// password  -  A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// See comments below regarding the encoding.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// Loaded document can be closed by FPDF_CloseDocument().
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// The encoding for |file_path| is UTF-8.
  ///
  /// The encoding for |password| can be either UTF-8 or Latin-1. PDFs,
  /// depending on the security handler revision, will only accept one or
  /// the other encoding. If |password|'s encoding and the PDF's expected
  /// encoding do not match, FPDF_LoadDocument() will automatically
  /// convert |password| to the other encoding.
  FPDF_DOCUMENT FPDF_LoadDocument(
    FPDF_STRING file_path,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadDocument(
      file_path,
      password,
    );
  }

  late final _FPDF_LoadDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(
              FPDF_STRING, FPDF_BYTESTRING)>>('FPDF_LoadDocument');
  late final _FPDF_LoadDocument = _FPDF_LoadDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(FPDF_STRING, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadMemDocument
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadMemDocument(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadMemDocument(
      data_buf,
      size,
      password,
    );
  }

  late final _FPDF_LoadMemDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Int,
              FPDF_BYTESTRING)>>('FPDF_LoadMemDocument');
  late final _FPDF_LoadMemDocument = _FPDF_LoadMemDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Function: FPDF_LoadMemDocument64
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadMemDocument64(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadMemDocument64(
      data_buf,
      size,
      password,
    );
  }

  late final _FPDF_LoadMemDocument64Ptr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Size,
              FPDF_BYTESTRING)>>('FPDF_LoadMemDocument64');
  late final _FPDF_LoadMemDocument64 = _FPDF_LoadMemDocument64Ptr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadCustomDocument
  /// Load PDF document from a custom access descriptor.
  /// Parameters:
  /// pFileAccess -   A structure for accessing the file.
  /// password    -   Optional password for decrypting the PDF file.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The application must keep the file resources |pFileAccess| points to
  /// valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|
  /// itself does not need to outlive the FPDF_DOCUMENT.
  ///
  /// The loaded document can be closed with FPDF_CloseDocument().
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadCustomDocument(
    ffi.Pointer<FPDF_FILEACCESS> pFileAccess,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadCustomDocument(
      pFileAccess,
      password,
    );
  }

  late final _FPDF_LoadCustomDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>,
              FPDF_BYTESTRING)>>('FPDF_LoadCustomDocument');
  late final _FPDF_LoadCustomDocument = _FPDF_LoadCustomDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetFileVersion
  /// Get the file version of the given PDF document.
  /// Parameters:
  /// doc         -   Handle to a document.
  /// fileVersion -   The PDF file version. File version: 14 for 1.4, 15
  /// for 1.5, ...
  /// Return value:
  /// True if succeeds, false otherwise.
  /// Comments:
  /// If the document was created by FPDF_CreateNewDocument,
  /// then this function will always fail.
  int FPDF_GetFileVersion(
    FPDF_DOCUMENT doc,
    ffi.Pointer<ffi.Int> fileVersion,
  ) {
    return _FPDF_GetFileVersion(
      doc,
      fileVersion,
    );
  }

  late final _FPDF_GetFileVersionPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT, ffi.Pointer<ffi.Int>)>>('FPDF_GetFileVersion');
  late final _FPDF_GetFileVersion = _FPDF_GetFileVersionPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDF_GetLastError
  /// Get last error code when a function fails.
  /// Parameters:
  /// None.
  /// Return value:
  /// A 32-bit integer indicating error code as defined above.
  /// Comments:
  /// If the previous SDK call succeeded, the return value of this
  /// function is not defined. This function only works in conjunction
  /// with APIs that mention FPDF_GetLastError() in their documentation.
  int FPDF_GetLastError() {
    return _FPDF_GetLastError();
  }

  late final _FPDF_GetLastErrorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'FPDF_GetLastError');
  late final _FPDF_GetLastError =
      _FPDF_GetLastErrorPtr.asFunction<int Function()>();

  /// Experimental API.
  /// Function: FPDF_DocumentHasValidCrossReferenceTable
  /// Whether the document's cross reference table is valid or not.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// True if the PDF parser did not encounter problems parsing the cross
  /// reference table. False if the parser could not parse the cross
  /// reference table and the table had to be rebuild from other data
  /// within the document.
  /// Comments:
  /// The return value can change over time as the PDF parser evolves.
  int FPDF_DocumentHasValidCrossReferenceTable(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_DocumentHasValidCrossReferenceTable(
      document,
    );
  }

  late final _FPDF_DocumentHasValidCrossReferenceTablePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'FPDF_DocumentHasValidCrossReferenceTable');
  late final _FPDF_DocumentHasValidCrossReferenceTable =
      _FPDF_DocumentHasValidCrossReferenceTablePtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetTrailerEnds
  /// Get the byte offsets of trailer ends.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// buffer      -   The address of a buffer that receives the
  /// byte offsets.
  /// length      -   The size, in ints, of |buffer|.
  /// Return value:
  /// Returns the number of ints in the buffer on success, 0 on error.
  ///
  /// |buffer| is an array of integers that describes the exact byte offsets of the
  /// trailer ends in the document. If |length| is less than the returned length,
  /// or |document| or |buffer| is NULL, |buffer| will not be modified.
  int FPDF_GetTrailerEnds(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.UnsignedInt> buffer,
    int length,
  ) {
    return _FPDF_GetTrailerEnds(
      document,
      buffer,
      length,
    );
  }

  late final _FPDF_GetTrailerEndsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedLong)>>('FPDF_GetTrailerEnds');
  late final _FPDF_GetTrailerEnds = _FPDF_GetTrailerEndsPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Function: FPDF_GetDocPermission
  /// Get file permission flags of the document.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// A 32-bit integer indicating permission flags. Please refer to the
  /// PDF Reference for detailed descriptions. If the document is not
  /// protected, 0xffffffff will be returned.
  int FPDF_GetDocPermissions(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetDocPermissions(
      document,
    );
  }

  late final _FPDF_GetDocPermissionsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_DOCUMENT)>>(
          'FPDF_GetDocPermissions');
  late final _FPDF_GetDocPermissions =
      _FPDF_GetDocPermissionsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetSecurityHandlerRevision
  /// Get the revision for the security handler.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// The security handler revision number. Please refer to the PDF
  /// Reference for a detailed description. If the document is not
  /// protected, -1 will be returned.
  int FPDF_GetSecurityHandlerRevision(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetSecurityHandlerRevision(
      document,
    );
  }

  late final _FPDF_GetSecurityHandlerRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetSecurityHandlerRevision');
  late final _FPDF_GetSecurityHandlerRevision =
      _FPDF_GetSecurityHandlerRevisionPtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetPageCount
  /// Get total number of pages in the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// Total number of pages in the document.
  int FPDF_GetPageCount(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetPageCount(
      document,
    );
  }

  late final _FPDF_GetPageCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetPageCount');
  late final _FPDF_GetPageCount =
      _FPDF_GetPageCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_LoadPage
  /// Load a page inside the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument
  /// page_index  -   Index number of the page. 0 for the first page.
  /// Return value:
  /// A handle to the loaded page, or NULL if page load fails.
  /// Comments:
  /// The loaded page can be rendered to devices using FPDF_RenderPage.
  /// The loaded page can be closed using FPDF_ClosePage.
  FPDF_PAGE FPDF_LoadPage(
    FPDF_DOCUMENT document,
    int page_index,
  ) {
    return _FPDF_LoadPage(
      document,
      page_index,
    );
  }

  late final _FPDF_LoadPagePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGE Function(FPDF_DOCUMENT, ffi.Int)>>(
          'FPDF_LoadPage');
  late final _FPDF_LoadPage =
      _FPDF_LoadPagePtr.asFunction<FPDF_PAGE Function(FPDF_DOCUMENT, int)>();

  /// Experimental API
  /// Function: FPDF_GetPageWidthF
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  double FPDF_GetPageWidthF(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageWidthF(
      page,
    );
  }

  late final _FPDF_GetPageWidthFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'FPDF_GetPageWidthF');
  late final _FPDF_GetPageWidthF =
      _FPDF_GetPageWidthFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageWidth
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  /// Note:
  /// Prefer FPDF_GetPageWidthF() above. This will be deprecated in the
  /// future.
  double FPDF_GetPageWidth(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageWidth(
      page,
    );
  }

  late final _FPDF_GetPageWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'FPDF_GetPageWidth');
  late final _FPDF_GetPageWidth =
      _FPDF_GetPageWidthPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API
  /// Function: FPDF_GetPageHeightF
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  double FPDF_GetPageHeightF(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageHeightF(
      page,
    );
  }

  late final _FPDF_GetPageHeightFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'FPDF_GetPageHeightF');
  late final _FPDF_GetPageHeightF =
      _FPDF_GetPageHeightFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageHeight
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  /// Note:
  /// Prefer FPDF_GetPageHeightF() above. This will be deprecated in the
  /// future.
  double FPDF_GetPageHeight(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageHeight(
      page,
    );
  }

  late final _FPDF_GetPageHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'FPDF_GetPageHeight');
  late final _FPDF_GetPageHeight =
      _FPDF_GetPageHeightPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API.
  /// Function: FPDF_GetPageBoundingBox
  /// Get the bounding box of the page. This is the intersection between
  /// its media box and its crop box.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// rect        -   Pointer to a rect to receive the page bounding box.
  /// On an error, |rect| won't be filled.
  /// Return value:
  /// True for success.
  int FPDF_GetPageBoundingBox(
    FPDF_PAGE page,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _FPDF_GetPageBoundingBox(
      page,
      rect,
    );
  }

  late final _FPDF_GetPageBoundingBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE, ffi.Pointer<FS_RECTF>)>>('FPDF_GetPageBoundingBox');
  late final _FPDF_GetPageBoundingBox = _FPDF_GetPageBoundingBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Function: FPDF_GetPageSizeByIndexF
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// page_index  -   Page index, zero for the first page.
  /// size        -   Pointer to a FS_SIZEF to receive the page size.
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  int FPDF_GetPageSizeByIndexF(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<FS_SIZEF> size,
  ) {
    return _FPDF_GetPageSizeByIndexF(
      document,
      page_index,
      size,
    );
  }

  late final _FPDF_GetPageSizeByIndexFPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Int,
              ffi.Pointer<FS_SIZEF>)>>('FPDF_GetPageSizeByIndexF');
  late final _FPDF_GetPageSizeByIndexF = _FPDF_GetPageSizeByIndexFPtr
      .asFunction<int Function(FPDF_DOCUMENT, int, ffi.Pointer<FS_SIZEF>)>();

  /// Function: FPDF_GetPageSizeByIndex
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// page_index  -   Page index, zero for the first page.
  /// width       -   Pointer to a double to receive the page width
  /// (in points).
  /// height      -   Pointer to a double to receive the page height
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  /// Note:
  /// Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in
  /// the future.
  int FPDF_GetPageSizeByIndex(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<ffi.Double> width,
    ffi.Pointer<ffi.Double> height,
  ) {
    return _FPDF_GetPageSizeByIndex(
      document,
      page_index,
      width,
      height,
    );
  }

  late final _FPDF_GetPageSizeByIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDF_GetPageSizeByIndex');
  late final _FPDF_GetPageSizeByIndex = _FPDF_GetPageSizeByIndexPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_RenderPage
  /// Render contents of a page to a device (screen, bitmap, or printer).
  /// This function is only supported on Windows.
  /// Parameters:
  /// dc          -   Handle to the device context.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// flags       -   0 for normal display, or combination of flags
  /// defined above.
  /// Return value:
  /// None.
  void FPDF_RenderPage(
    HDC dc,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _FPDF_RenderPage(
      dc,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _FPDF_RenderPagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(HDC, FPDF_PAGE, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int)>>('FPDF_RenderPage');
  late final _FPDF_RenderPage = _FPDF_RenderPagePtr.asFunction<
      void Function(HDC, FPDF_PAGE, int, int, int, int, int, int)>();

  /// Function: FPDF_RenderPageBitmap
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved from an image
  /// object by FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage
  /// start_x     -   Left pixel position of the display area in
  /// bitmap coordinates.
  /// start_y     -   Top pixel position of the display area in bitmap
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None.
  void FPDF_RenderPageBitmap(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _FPDF_RenderPageBitmap(
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _FPDF_RenderPageBitmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int)>>('FPDF_RenderPageBitmap');
  late final _FPDF_RenderPageBitmap = _FPDF_RenderPageBitmapPtr.asFunction<
      void Function(FPDF_BITMAP, FPDF_PAGE, int, int, int, int, int, int)>();

  /// Function: FPDF_RenderPageBitmapWithMatrix
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved by
  /// FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// matrix      -   The transform matrix, which must be invertible.
  /// See PDF Reference 1.7, 4.2.2 Common Transformations.
  /// clipping    -   The rect to clip to in device coords.
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None. Note that behavior is undefined if det of |matrix| is 0.
  void FPDF_RenderPageBitmapWithMatrix(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    ffi.Pointer<FS_MATRIX> matrix,
    ffi.Pointer<FS_RECTF> clipping,
    int flags,
  ) {
    return _FPDF_RenderPageBitmapWithMatrix(
      bitmap,
      page,
      matrix,
      clipping,
      flags,
    );
  }

  late final _FPDF_RenderPageBitmapWithMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_BITMAP,
              FPDF_PAGE,
              ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>,
              ffi.Int)>>('FPDF_RenderPageBitmapWithMatrix');
  late final _FPDF_RenderPageBitmapWithMatrix =
      _FPDF_RenderPageBitmapWithMatrixPtr.asFunction<
          void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>, int)>();

  /// Function: FPDF_ClosePage
  /// Close a loaded PDF page.
  /// Parameters:
  /// page        -   Handle to the loaded page.
  /// Return value:
  /// None.
  void FPDF_ClosePage(
    FPDF_PAGE page,
  ) {
    return _FPDF_ClosePage(
      page,
    );
  }

  late final _FPDF_ClosePagePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE)>>(
          'FPDF_ClosePage');
  late final _FPDF_ClosePage =
      _FPDF_ClosePagePtr.asFunction<void Function(FPDF_PAGE)>();

  /// Function: FPDF_CloseDocument
  /// Close a loaded PDF document.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  void FPDF_CloseDocument(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_CloseDocument(
      document,
    );
  }

  late final _FPDF_CloseDocumentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DOCUMENT)>>(
          'FPDF_CloseDocument');
  late final _FPDF_CloseDocument =
      _FPDF_CloseDocumentPtr.asFunction<void Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_DeviceToPage
  /// Convert the screen coordinates of a point to page coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// device_x    -   X value in device coordinates to be converted.
  /// device_y    -   Y value in device coordinates to be converted.
  /// page_x      -   A pointer to a double receiving the converted X
  /// value in page coordinates.
  /// page_y      -   A pointer to a double receiving the converted Y
  /// value in page coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |page_x| and |page_y|
  /// successfully receives the converted coordinates.
  /// Comments:
  /// The page coordinate system has its origin at the left-bottom corner
  /// of the page, with the X-axis on the bottom going to the right, and
  /// the Y-axis on the left side going up.
  ///
  /// NOTE: this coordinate system can be altered when you zoom, scroll,
  /// or rotate a page, however, a point on the page should always have
  /// the same coordinate values in the page coordinate system.
  ///
  /// The device coordinate system is device dependent. For screen device,
  /// its origin is at the left-top corner of the window. However this
  /// origin can be altered by the Windows coordinate transformation
  /// utilities.
  ///
  /// You must make sure the start_x, start_y, size_x, size_y
  /// and rotate parameters have exactly same values as you used in
  /// the FPDF_RenderPage() function call.
  int FPDF_DeviceToPage(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int device_x,
    int device_y,
    ffi.Pointer<ffi.Double> page_x,
    ffi.Pointer<ffi.Double> page_y,
  ) {
    return _FPDF_DeviceToPage(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      device_x,
      device_y,
      page_x,
      page_y,
    );
  }

  late final _FPDF_DeviceToPagePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDF_DeviceToPage');
  late final _FPDF_DeviceToPage = _FPDF_DeviceToPagePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_PageToDevice
  /// Convert the page coordinates of a point to screen coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// page_x      -   X value in page coordinates.
  /// page_y      -   Y value in page coordinate.
  /// device_x    -   A pointer to an integer receiving the result X
  /// value in device coordinates.
  /// device_y    -   A pointer to an integer receiving the result Y
  /// value in device coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |device_x| and
  /// |device_y| successfully receives the converted coordinates.
  /// Comments:
  /// See comments for FPDF_DeviceToPage().
  int FPDF_PageToDevice(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    double page_x,
    double page_y,
    ffi.Pointer<ffi.Int> device_x,
    ffi.Pointer<ffi.Int> device_y,
  ) {
    return _FPDF_PageToDevice(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      page_x,
      page_y,
      device_x,
      device_y,
    );
  }

  late final _FPDF_PageToDevicePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('FPDF_PageToDevice');
  late final _FPDF_PageToDevice = _FPDF_PageToDevicePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, double, double,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDFBitmap_Create
  /// Create a device independent bitmap (FXDIB).
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// alpha       -   A flag indicating whether the alpha channel is used.
  /// Non-zero for using alpha, zero for not using.
  /// Return value:
  /// The created bitmap handle, or NULL if a parameter error or out of
  /// memory.
  /// Comments:
  /// The bitmap always uses 4 bytes per pixel. The first byte is always
  /// double word aligned.
  ///
  /// The byte order is BGRx (the last byte unused if no alpha channel) or
  /// BGRA.
  ///
  /// The pixels in a horizontal line are stored side by side, with the
  /// left most pixel stored first (with lower memory address).
  /// Each line uses width * 4 bytes.
  ///
  /// Lines are stored one after another, with the top most line stored
  /// first. There is no gap between adjacent lines.
  ///
  /// This function allocates enough memory for holding all pixels in the
  /// bitmap, but it doesn't initialize the buffer. Applications can use
  /// FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS
  /// allows it, this function can allocate up to 4 GB of memory.
  FPDF_BITMAP FPDFBitmap_Create(
    int width,
    int height,
    int alpha,
  ) {
    return _FPDFBitmap_Create(
      width,
      height,
      alpha,
    );
  }

  late final _FPDFBitmap_CreatePtr = _lookup<
          ffi.NativeFunction<FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int)>>(
      'FPDFBitmap_Create');
  late final _FPDFBitmap_Create =
      _FPDFBitmap_CreatePtr.asFunction<FPDF_BITMAP Function(int, int, int)>();

  /// Function: FPDFBitmap_CreateEx
  /// Create a device independent bitmap (FXDIB)
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// format      -   A number indicating for bitmap format, as defined
  /// above.
  /// first_scan  -   A pointer to the first byte of the first line if
  /// using an external buffer. If this parameter is NULL,
  /// then a new buffer will be created.
  /// stride      -   Number of bytes for each scan line. The value must
  /// be 0 or greater. When the value is 0,
  /// FPDFBitmap_CreateEx() will automatically calculate
  /// the appropriate value using |width| and |format|.
  /// When using an external buffer, it is recommended for
  /// the caller to pass in the value.
  /// When not using an external buffer, it is recommended
  /// for the caller to pass in 0.
  /// Return value:
  /// The bitmap handle, or NULL if parameter error or out of memory.
  /// Comments:
  /// Similar to FPDFBitmap_Create function, but allows for more formats
  /// and an external buffer is supported. The bitmap created by this
  /// function can be used in any place that a FPDF_BITMAP handle is
  /// required.
  ///
  /// If an external buffer is used, then the caller should destroy the
  /// buffer. FPDFBitmap_Destroy() will not destroy the buffer.
  ///
  /// It is recommended to use FPDFBitmap_GetStride() to get the stride
  /// value.
  FPDF_BITMAP FPDFBitmap_CreateEx(
    int width,
    int height,
    int format,
    ffi.Pointer<ffi.Void> first_scan,
    int stride,
  ) {
    return _FPDFBitmap_CreateEx(
      width,
      height,
      format,
      first_scan,
      stride,
    );
  }

  late final _FPDFBitmap_CreateExPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('FPDFBitmap_CreateEx');
  late final _FPDFBitmap_CreateEx = _FPDFBitmap_CreateExPtr.asFunction<
      FPDF_BITMAP Function(int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDFBitmap_GetFormat
  /// Get the format of the bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The format of the bitmap.
  /// Comments:
  /// Only formats supported by FPDFBitmap_CreateEx are supported by this
  /// function; see the list of such formats above.
  int FPDFBitmap_GetFormat(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetFormat(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetFormatPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetFormat');
  late final _FPDFBitmap_GetFormat =
      _FPDFBitmap_GetFormatPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_FillRect
  /// Fill a rectangle in a bitmap.
  /// Parameters:
  /// bitmap      -   The handle to the bitmap. Returned by
  /// FPDFBitmap_Create.
  /// left        -   The left position. Starting from 0 at the
  /// left-most pixel.
  /// top         -   The top position. Starting from 0 at the
  /// top-most line.
  /// width       -   Width in pixels to be filled.
  /// height      -   Height in pixels to be filled.
  /// color       -   A 32-bit value specifing the color, in 8888 ARGB
  /// format.
  /// Return value:
  /// None.
  /// Comments:
  /// This function sets the color and (optionally) alpha value in the
  /// specified region of the bitmap.
  ///
  /// NOTE: If the alpha channel is used, this function does NOT
  /// composite the background with the source color, instead the
  /// background will be replaced by the source color and the alpha.
  ///
  /// If the alpha channel is not used, the alpha parameter is ignored.
  void FPDFBitmap_FillRect(
    FPDF_BITMAP bitmap,
    int left,
    int top,
    int width,
    int height,
    int color,
  ) {
    return _FPDFBitmap_FillRect(
      bitmap,
      left,
      top,
      width,
      height,
      color,
    );
  }

  late final _FPDFBitmap_FillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_BITMAP, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              FPDF_DWORD)>>('FPDFBitmap_FillRect');
  late final _FPDFBitmap_FillRect = _FPDFBitmap_FillRectPtr.asFunction<
      void Function(FPDF_BITMAP, int, int, int, int, int)>();

  /// Function: FPDFBitmap_GetBuffer
  /// Get data buffer of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The pointer to the first byte of the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel
  ///
  /// Applications can use this function to get the bitmap buffer pointer,
  /// then manipulate any color and/or alpha values for any pixels in the
  /// bitmap.
  ///
  /// The data is in BGRA format. Where the A maybe unused if alpha was
  /// not specified.
  ffi.Pointer<ffi.Void> FPDFBitmap_GetBuffer(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetBuffer(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetBuffer');
  late final _FPDFBitmap_GetBuffer = _FPDFBitmap_GetBufferPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetWidth
  /// Get width of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The width of the bitmap in pixels.
  int FPDFBitmap_GetWidth(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetWidth(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetWidth');
  late final _FPDFBitmap_GetWidth =
      _FPDFBitmap_GetWidthPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetHeight
  /// Get height of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The height of the bitmap in pixels.
  int FPDFBitmap_GetHeight(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetHeight(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetHeight');
  late final _FPDFBitmap_GetHeight =
      _FPDFBitmap_GetHeightPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetStride
  /// Get number of bytes for each line in the bitmap buffer.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The number of bytes for each line in the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel.
  int FPDFBitmap_GetStride(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetStride(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetStridePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetStride');
  late final _FPDFBitmap_GetStride =
      _FPDFBitmap_GetStridePtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_Destroy
  /// Destroy a bitmap and release all related buffers.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// None.
  /// Comments:
  /// This function will not destroy any external buffers provided when
  /// the bitmap was created.
  void FPDFBitmap_Destroy(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_Destroy(
      bitmap,
    );
  }

  late final _FPDFBitmap_DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_BITMAP)>>(
          'FPDFBitmap_Destroy');
  late final _FPDFBitmap_Destroy =
      _FPDFBitmap_DestroyPtr.asFunction<void Function(FPDF_BITMAP)>();

  /// Function: FPDF_VIEWERREF_GetPrintScaling
  /// Whether the PDF document prefers to be scaled or not.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  int FPDF_VIEWERREF_GetPrintScaling(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetPrintScaling(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintScalingPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetPrintScaling');
  late final _FPDF_VIEWERREF_GetPrintScaling =
      _FPDF_VIEWERREF_GetPrintScalingPtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetNumCopies
  /// Returns the number of copies to be printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The number of copies to be printed.
  int FPDF_VIEWERREF_GetNumCopies(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetNumCopies(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetNumCopiesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetNumCopies');
  late final _FPDF_VIEWERREF_GetNumCopies =
      _FPDF_VIEWERREF_GetNumCopiesPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetPrintPageRange
  /// Page numbers to initialize print dialog box when file is printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The print page range to be used for printing.
  FPDF_PAGERANGE FPDF_VIEWERREF_GetPrintPageRange(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRange(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGERANGE Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetPrintPageRange');
  late final _FPDF_VIEWERREF_GetPrintPageRange =
      _FPDF_VIEWERREF_GetPrintPageRangePtr.asFunction<
          FPDF_PAGERANGE Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeCount
  /// Returns the number of elements in a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// Return value:
  /// The number of elements in the page range. Returns 0 on error.
  int FPDF_VIEWERREF_GetPrintPageRangeCount(
    FPDF_PAGERANGE pagerange,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRangeCount(
      pagerange,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangeCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(FPDF_PAGERANGE)>>(
          'FPDF_VIEWERREF_GetPrintPageRangeCount');
  late final _FPDF_VIEWERREF_GetPrintPageRangeCount =
      _FPDF_VIEWERREF_GetPrintPageRangeCountPtr.asFunction<
          int Function(FPDF_PAGERANGE)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeElement
  /// Returns an element from a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// index       -   Index of the element.
  /// Return value:
  /// The value of the element in the page range at a given index.
  /// Returns -1 on error.
  int FPDF_VIEWERREF_GetPrintPageRangeElement(
    FPDF_PAGERANGE pagerange,
    int index,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRangeElement(
      pagerange,
      index,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangeElementPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGERANGE, ffi.Size)>>(
          'FPDF_VIEWERREF_GetPrintPageRangeElement');
  late final _FPDF_VIEWERREF_GetPrintPageRangeElement =
      _FPDF_VIEWERREF_GetPrintPageRangeElementPtr.asFunction<
          int Function(FPDF_PAGERANGE, int)>();

  /// Function: FPDF_VIEWERREF_GetDuplex
  /// Returns the paper handling option to be used when printing from
  /// the print dialog.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The paper handling option to be used when printing.
  int FPDF_VIEWERREF_GetDuplex(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetDuplex(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetDuplexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetDuplex');
  late final _FPDF_VIEWERREF_GetDuplex =
      _FPDF_VIEWERREF_GetDuplexPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetName
  /// Gets the contents for a viewer ref, with a given key. The value must
  /// be of type "name".
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// key         -   Name of the key in the viewer pref dictionary,
  /// encoded in UTF-8.
  /// buffer      -   A string to write the contents of the key to.
  /// length      -   Length of the buffer.
  /// Return value:
  /// The number of bytes in the contents, including the NULL terminator.
  /// Thus if the return value is 0, then that indicates an error, such
  /// as when |document| is invalid or |buffer| is NULL. If |length| is
  /// less than the returned length, or |buffer| is NULL, |buffer| will
  /// not be modified.
  int FPDF_VIEWERREF_GetName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _FPDF_VIEWERREF_GetName(
      document,
      key,
      buffer,
      length,
    );
  }

  late final _FPDF_VIEWERREF_GetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('FPDF_VIEWERREF_GetName');
  late final _FPDF_VIEWERREF_GetName = _FPDF_VIEWERREF_GetNamePtr.asFunction<
      int Function(
          FPDF_DOCUMENT, FPDF_BYTESTRING, ffi.Pointer<ffi.Char>, int)>();

  /// Function: FPDF_CountNamedDests
  /// Get the count of named destinations in the PDF document.
  /// Parameters:
  /// document    -   Handle to a document
  /// Return value:
  /// The count of named destinations.
  int FPDF_CountNamedDests(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_CountNamedDests(
      document,
    );
  }

  late final _FPDF_CountNamedDestsPtr =
      _lookup<ffi.NativeFunction<FPDF_DWORD Function(FPDF_DOCUMENT)>>(
          'FPDF_CountNamedDests');
  late final _FPDF_CountNamedDests =
      _FPDF_CountNamedDestsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetNamedDestByName
  /// Get a the destination handle for the given name.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// name        -   The name of a destination.
  /// Return value:
  /// The handle to the destination.
  FPDF_DEST FPDF_GetNamedDestByName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING name,
  ) {
    return _FPDF_GetNamedDestByName(
      document,
      name,
    );
  }

  late final _FPDF_GetNamedDestByNamePtr = _lookup<
      ffi.NativeFunction<
          FPDF_DEST Function(
              FPDF_DOCUMENT, FPDF_BYTESTRING)>>('FPDF_GetNamedDestByName');
  late final _FPDF_GetNamedDestByName = _FPDF_GetNamedDestByNamePtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetNamedDest
  /// Get the named destination by index.
  /// Parameters:
  /// document        -   Handle to a document
  /// index           -   The index of a named destination.
  /// buffer          -   The buffer to store the destination name,
  /// used as wchar_t*.
  /// buflen [in/out] -   Size of the buffer in bytes on input,
  /// length of the result in bytes on output
  /// or -1 if the buffer is too small.
  /// Return value:
  /// The destination handle for a given index, or NULL if there is no
  /// named destination corresponding to |index|.
  /// Comments:
  /// Call this function twice to get the name of the named destination:
  /// 1) First time pass in |buffer| as NULL and get buflen.
  /// 2) Second time pass in allocated |buffer| and buflen to retrieve
  /// |buffer|, which should be used as wchar_t*.
  ///
  /// If buflen is not sufficiently large, it will be set to -1 upon
  /// return.
  FPDF_DEST FPDF_GetNamedDest(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    ffi.Pointer<ffi.Long> buflen,
  ) {
    return _FPDF_GetNamedDest(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _FPDF_GetNamedDestPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DEST Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Long>)>>('FPDF_GetNamedDest');
  late final _FPDF_GetNamedDest = _FPDF_GetNamedDestPtr.asFunction<
      FPDF_DEST Function(
          FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Long>)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketCount
  /// Get the number of valid packets in the XFA entry.
  /// Parameters:
  /// document - Handle to the document.
  /// Return value:
  /// The number of valid packets, or -1 on error.
  int FPDF_GetXFAPacketCount(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetXFAPacketCount(
      document,
    );
  }

  late final _FPDF_GetXFAPacketCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetXFAPacketCount');
  late final _FPDF_GetXFAPacketCount =
      _FPDF_GetXFAPacketCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketName
  /// Get the name of a packet in the XFA array.
  /// Parameters:
  /// document - Handle to the document.
  /// index    - Index number of the packet. 0 for the first packet.
  /// buffer   - Buffer for holding the name of the XFA packet.
  /// buflen   - Length of |buffer| in bytes.
  /// Return value:
  /// The length of the packet name in bytes, or 0 on error.
  ///
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount().
  /// |buffer| is only modified if it is non-NULL and |buflen| is greater than or
  /// equal to the length of the packet name. The packet name includes a
  /// terminating NUL character. |buffer| is unmodified on error.
  int FPDF_GetXFAPacketName(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _FPDF_GetXFAPacketName(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _FPDF_GetXFAPacketNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('FPDF_GetXFAPacketName');
  late final _FPDF_GetXFAPacketName = _FPDF_GetXFAPacketNamePtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketContent
  /// Get the content of a packet in the XFA array.
  /// Parameters:
  /// document   - Handle to the document.
  /// index      - Index number of the packet. 0 for the first packet.
  /// buffer     - Buffer for holding the content of the XFA packet.
  /// buflen     - Length of |buffer| in bytes.
  /// out_buflen - Pointer to the variable that will receive the minimum
  /// buffer size needed to contain the content of the XFA
  /// packet.
  /// Return value:
  /// Whether the operation succeeded or not.
  ///
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be
  /// NULL. When the aforementioned arguments are valid, the operation succeeds,
  /// and |out_buflen| receives the content size. |buffer| is only modified if
  /// |buffer| is non-null and long enough to contain the content. Callers must
  /// check both the return value and the input |buflen| is no less than the
  /// returned |out_buflen| before using the data in |buffer|.
  int FPDF_GetXFAPacketContent(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _FPDF_GetXFAPacketContent(
      document,
      index,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _FPDF_GetXFAPacketContentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedLong>)>>('FPDF_GetXFAPacketContent');
  late final _FPDF_GetXFAPacketContent =
      _FPDF_GetXFAPacketContentPtr.asFunction<
          int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.UnsignedLong>)>();
}

/// Process-wide options for initializing the library.
typedef FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;

/// Process-wide options for initializing the library.
class FPDF_LIBRARY_CONFIG_ extends ffi.Struct {
  /// Version number of the interface. Currently must be 2.
  /// Support for version 1 will be deprecated in the future.
  @ffi.Int()
  external int version;

  /// Array of paths to scan in place of the defaults when using built-in
  /// FXGE font loading code. The array is terminated by a NULL pointer.
  /// The Array may be NULL itself to use the default paths. May be ignored
  /// entirely depending upon the platform.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> m_pUserFontPaths;

  /// Pointer to the v8::Isolate to use, or NULL to force PDFium to create one.
  external ffi.Pointer<ffi.Void> m_pIsolate;

  /// The embedder data slot to use in the v8::Isolate to store PDFium's
  /// per-isolate data. The value needs to be in the range
  /// [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most
  /// embedders.
  @ffi.UnsignedInt()
  external int m_v8EmbedderSlot;

  /// Pointer to the V8::Platform to use.
  external ffi.Pointer<ffi.Void> m_pPlatform;
}

typedef FPDF_DWORD = ffi.UnsignedLong;

/// Basic data types
typedef FPDF_BOOL = ffi.Int;
typedef FPDF_DOCUMENT = ffi.Pointer<fpdf_document_t__>;

class fpdf_document_t__ extends ffi.Opaque {}

/// For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a
/// Windows unicode string, however, special care needs to be taken if you
/// expect to process Unicode larger than 0xffff.
///
/// For Linux/Unix programmers: most compiler/library environments use 4 bytes
/// for a Unicode character, and you have to convert between FPDF_WIDESTRING and
/// system wide string by yourself.
typedef FPDF_STRING = ffi.Pointer<ffi.Char>;

/// FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE
/// encoded), and platform dependent string
typedef FPDF_BYTESTRING = ffi.Pointer<ffi.Char>;

/// Structure for custom file access.
class FPDF_FILEACCESS extends ffi.Struct {
  /// File length, in bytes.
  @ffi.UnsignedLong()
  external int m_FileLen;

  /// A function pointer for getting a block of data from a specific position.
  /// Position is specified by byte offset from the beginning of the file.
  /// The pointer to the buffer is never NULL and the size is never 0.
  /// The position and size will never go out of range of the file length.
  /// It may be possible for FPDFSDK to call this function multiple times for
  /// the same position.
  /// Return value: should be non-zero if successful, zero for error.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedLong)>> m_GetBlock;

  /// A custom pointer for all implementation specific data.  This pointer will
  /// be used as the first parameter to the m_GetBlock callback.
  external ffi.Pointer<ffi.Void> m_Param;
}

typedef FPDF_PAGE = ffi.Pointer<fpdf_page_t__>;

class fpdf_page_t__ extends ffi.Opaque {}

/// Rectangle area(float) in device or page coordinate system.
typedef FS_RECTF = _FS_RECTF_;

/// Rectangle area(float) in device or page coordinate system.
class _FS_RECTF_ extends ffi.Struct {
  /// The x-coordinate of the left-top corner.
  @ffi.Float()
  external double left;

  /// The y-coordinate of the left-top corner.
  @ffi.Float()
  external double top;

  /// The x-coordinate of the right-bottom corner.
  @ffi.Float()
  external double right;

  /// The y-coordinate of the right-bottom corner.
  @ffi.Float()
  external double bottom;
}

/// Rectangle size. Coordinate system agnostic.
typedef FS_SIZEF = FS_SIZEF_;

/// Rectangle size. Coordinate system agnostic.
class FS_SIZEF_ extends ffi.Struct {
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

typedef HDC = ffi.Pointer<HDC__>;

class HDC__ extends ffi.Struct {
  @ffi.Int()
  external int unused;
}

typedef FPDF_BITMAP = ffi.Pointer<fpdf_bitmap_t__>;

class fpdf_bitmap_t__ extends ffi.Opaque {}

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
typedef FS_MATRIX = _FS_MATRIX_;

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
class _FS_MATRIX_ extends ffi.Struct {
  @ffi.Float()
  external double a;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double c;

  @ffi.Float()
  external double d;

  @ffi.Float()
  external double e;

  @ffi.Float()
  external double f;
}

typedef FPDF_PAGERANGE = ffi.Pointer<fpdf_pagerange_t__>;

class fpdf_pagerange_t__ extends ffi.Opaque {}

/// Duplex types
abstract class _FPDF_DUPLEXTYPE_ {
  static const int DuplexUndefined = 0;
  static const int Simplex = 1;
  static const int DuplexFlipShortEdge = 2;
  static const int DuplexFlipLongEdge = 3;
}

typedef FPDF_DEST = ffi.Pointer<fpdf_dest_t__>;

class fpdf_dest_t__ extends ffi.Opaque {}

const int FPDF_OBJECT_UNKNOWN = 0;

const int FPDF_OBJECT_BOOLEAN = 1;

const int FPDF_OBJECT_NUMBER = 2;

const int FPDF_OBJECT_STRING = 3;

const int FPDF_OBJECT_NAME = 4;

const int FPDF_OBJECT_ARRAY = 5;

const int FPDF_OBJECT_DICTIONARY = 6;

const int FPDF_OBJECT_STREAM = 7;

const int FPDF_OBJECT_NULLOBJ = 8;

const int FPDF_OBJECT_REFERENCE = 9;

const int FPDF_POLICY_MACHINETIME_ACCESS = 0;

const int FPDF_ERR_SUCCESS = 0;

const int FPDF_ERR_UNKNOWN = 1;

const int FPDF_ERR_FILE = 2;

const int FPDF_ERR_FORMAT = 3;

const int FPDF_ERR_PASSWORD = 4;

const int FPDF_ERR_SECURITY = 5;

const int FPDF_ERR_PAGE = 6;

const int FPDF_ANNOT = 1;

const int FPDF_LCD_TEXT = 2;

const int FPDF_NO_NATIVETEXT = 4;

const int FPDF_GRAYSCALE = 8;

const int FPDF_DEBUG_INFO = 128;

const int FPDF_NO_CATCH = 256;

const int FPDF_RENDER_LIMITEDIMAGECACHE = 512;

const int FPDF_RENDER_FORCEHALFTONE = 1024;

const int FPDF_PRINTING = 2048;

const int FPDF_RENDER_NO_SMOOTHTEXT = 4096;

const int FPDF_RENDER_NO_SMOOTHIMAGE = 8192;

const int FPDF_RENDER_NO_SMOOTHPATH = 16384;

const int FPDF_REVERSE_BYTE_ORDER = 16;

const int FPDF_CONVERT_FILL_TO_STROKE = 32;
